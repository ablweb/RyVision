import {
  CopyShader
} from "./chunk-NY4Z4LNU.js";
import {
  FullScreenQuad,
  Pass
} from "./chunk-HPNQ4DEU.js";
import {
  HalfFloatType,
  NearestFilter,
  NoBlending,
  ShaderMaterial,
  UniformsUtils,
  WebGLRenderTarget
} from "./chunk-X3JBSZVA.js";

// node_modules/three/examples/jsm/shaders/AfterimageShader.js
var AfterimageShader = {
  name: "AfterimageShader",
  uniforms: {
    "damp": { value: 0.96 },
    "tOld": { value: null },
    "tNew": { value: null }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float damp;

		uniform sampler2D tOld;
		uniform sampler2D tNew;

		varying vec2 vUv;

		vec4 when_gt( vec4 x, float y ) {

			return max( sign( x - y ), 0.0 );

		}

		void main() {

			vec4 texelOld = texture2D( tOld, vUv );
			vec4 texelNew = texture2D( tNew, vUv );

			texelOld *= damp * when_gt( texelOld, 0.1 );

			gl_FragColor = max(texelNew, texelOld);

		}`
  )
};

// node_modules/three/examples/jsm/postprocessing/AfterimagePass.js
var AfterimagePass = class extends Pass {
  /**
   * Constructs a new after image pass.
   *
   * @param {number} [damp=0.96] - The damping intensity. A higher value means a stronger after image effect.
   */
  constructor(damp = 0.96) {
    super();
    this.uniforms = UniformsUtils.clone(AfterimageShader.uniforms);
    this.damp = damp;
    this.compFsMaterial = new ShaderMaterial({
      uniforms: this.uniforms,
      vertexShader: AfterimageShader.vertexShader,
      fragmentShader: AfterimageShader.fragmentShader
    });
    this.copyFsMaterial = new ShaderMaterial({
      uniforms: UniformsUtils.clone(CopyShader.uniforms),
      vertexShader: CopyShader.vertexShader,
      fragmentShader: CopyShader.fragmentShader,
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
    this._textureComp = new WebGLRenderTarget(window.innerWidth, window.innerHeight, {
      magFilter: NearestFilter,
      type: HalfFloatType
    });
    this._textureOld = new WebGLRenderTarget(window.innerWidth, window.innerHeight, {
      magFilter: NearestFilter,
      type: HalfFloatType
    });
    this._compFsQuad = new FullScreenQuad(this.compFsMaterial);
    this._copyFsQuad = new FullScreenQuad(this.copyFsMaterial);
  }
  /**
   * The damping intensity, from 0.0 to 1.0. A higher value means a stronger after image effect.
   *
   * @type {number}
   */
  get damp() {
    return this.uniforms["damp"].value;
  }
  set damp(value) {
    this.uniforms["damp"].value = value;
  }
  /**
   * Performs the after image pass.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(renderer, writeBuffer, readBuffer) {
    this.uniforms["tOld"].value = this._textureOld.texture;
    this.uniforms["tNew"].value = readBuffer.texture;
    renderer.setRenderTarget(this._textureComp);
    this._compFsQuad.render(renderer);
    this._copyFsQuad.material.uniforms.tDiffuse.value = this._textureComp.texture;
    if (this.renderToScreen) {
      renderer.setRenderTarget(null);
      this._copyFsQuad.render(renderer);
    } else {
      renderer.setRenderTarget(writeBuffer);
      if (this.clear) renderer.clear();
      this._copyFsQuad.render(renderer);
    }
    const temp = this._textureOld;
    this._textureOld = this._textureComp;
    this._textureComp = temp;
  }
  /**
   * Sets the size of the pass.
   *
   * @param {number} width - The width to set.
   * @param {number} height - The height to set.
   */
  setSize(width, height) {
    this._textureComp.setSize(width, height);
    this._textureOld.setSize(width, height);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the pass is no longer used in your app.
   */
  dispose() {
    this._textureComp.dispose();
    this._textureOld.dispose();
    this.compFsMaterial.dispose();
    this.copyFsMaterial.dispose();
    this._compFsQuad.dispose();
    this._copyFsQuad.dispose();
  }
};
export {
  AfterimagePass
};
//# sourceMappingURL=three_examples_jsm_postprocessing_AfterimagePass__js.js.map
